Домашнее задание из личного кабинета.

Цель: получить практический опыт установки пакетов с помощью
сторонних репозиториев и пакетного менеджера. Научиться
выполнять задачи автоматизации с помощью Bash.
Задание 3 – написать Bash-скрипт в соответствии с требованиями:
Содержание скрипта: замена существующего расширения в имени файла на
заданное. Исходное имя файла и новое расширение передаются скрипту в
качестве параметров. Основное средство: нестандартное раскрытие
переменных. Усложнение: предусмотреть штатную реакцию на отсутствие
расширения в исходном имени файла.

Задание 4 – написать Bash-скрипт в соответствии с требованиями:
Содержание скрипта: выделение из исходной строки подстроки с границами,
заданными порядковыми номерами символов в исходной строке. Усложнение:
предусмотреть возможность не выделения, а удаления подстроки.Основные
средства: команда cut, переменные оболочки

Выполнение задания 3:
Скрипт выглядит так 
![Script1](https://github.com/annette-medvedeva/Medvedeva_Anna_DOS24/blob/HomeWork4/Task3/Script3.png)

if [ $# -ne 2 ]; then
  echo "Usage: $0 <filename> <new_extension>"
  exit 1
fi

Здесь проверяется, переданы ли два аргумента в скрипт. Если нет, выводится сообщение о правильном использовании скрипта, и он завершает работу с кодом ошибки 1.

Получение аргументов:
original_file="$1"
new_extension="$2"

Первый аргумент (имя файла) сохраняется в переменной original_file, а второй аргумент (новое расширение) — в new_extension.
Проверка существования файла:
if [ ! -f "$original_file" ]; then
  echo "File '$original_file' does not exist."
  exit 1
fi

Здесь проверяется, существует ли файл, указанный в original_file. Если файл не найден, выводится сообщение об ошибке, и скрипт завершает работу.
Получение базового имени файла: base_name="$(basename "$original_file" | cut -f 1 -d '.')"

Функция basename возвращает имя файла без пути, а cut используется для получения базового имени без расширения (все, что до первой точки).
Формирование нового имени файла: new_file="${base_name}.${new_extension}"
Здесь создается новое имя файла, добавляя новое расширение к базовому имени.
Копирование файла с новым именем: cp "$original_file" "$new_file"
Файл копируется с новым именем.
Успешное завершение: echo "New file created as '$new_file'"


Как выполнить этот скрипт
Дать права на выполнение: chmod +x rename_extansion.sh

Запуск скрипта:
./rename_extansion.sh test.txt md
![Result_Script1](https://github.com/annette-medvedeva/Medvedeva_Anna_DOS24/blob/HomeWork4/Task3/Result_script3.png)


Выполнение задания 4:
Проверяется, переданы ли хотя бы три аргумента (строка, начальный индекс и конечный индекс). Если нет, выводится сообщение об использовании скрипта и он завершает работу с кодом ошибки 1.
if [ $# -lt 3 ]; then
  echo "Использование: $0 <строка> <начало> <конец> [-d]"
  echo "Параметры:"
  echo "  <строка>  - исходная строка"
  echo "  <начало>  - порядковый номер начального символа подстроки (1-индексация)"
  echo "  <конец>   - порядковый номер конечного символа подстроки (включительно)"
  echo "  -d        - флаг для удаления подстроки вместо выделения"
  exit 1
fi

Переменные:
input_string="$1"
start=$2
end=$3
delete_mode=false

Проверка флага -d для режима удаления:
if [ "$4" == "-d" ]; then
  delete_mode=true
fi
Если четвертый аргумент равен -d, то delete_mode устанавливается в true, что означает, что вместо извлечения подстроки будет производиться ее удаление.

Обработка подстроки с помощью awk: awk -v s="$start" -v e="$end" '{print substr($0, s, e-s+1)}' <<< "$input_string"


Если включен режим удаления: awk -v s="$start" -v e="$end" '{print substr($0, 1, s-1) substr($0, e+1)}' <<< "$input_string"
awk использует функции substr для создания новой строки, исключая подстроку между заданными индексами.

Если режим удаления не включен:  awk -v s="$start" -v e="$end" '{print substr($0, s, e-s+1)}' <<< "$input_string"
awk извлекает подстроку с начального индекса s и длиной e-s+1.


Как выполнить этот скрипт
Дать права на выполнение:
chmod +x Script4.sh

./Script4.sh "Hello, World!" 1 5
Это вернет подстроку Hello (от символа 1 до символа 5).

удалить подстроку
./Script4.sh "Hello, World!" 1 5 -d

Результат работы скрипта:
![Script1](https://github.com/annette-medvedeva/Medvedeva_Anna_DOS24/blob/HomeWork4/Task4/Result_Script4.png)








